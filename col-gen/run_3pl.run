# digits of precision to which displayed numbers are rounded;full precision=0
option display_precision 0;

# display constraints
param flag_do_expand default 0;
# display solutions after solving each master/pricer
param flag_print_sol default 0;
# print master dual variables
param flag_print_duals default 0;

# compute the tuples of sequences indentifying terminal nodes of the games
# HP: no terminal nodes have values (0,0,0)
let {q1 in Q1, q2 in Q2, q3 in Q3} suppU[q1,q2,q3] := if ( U1[q1,q2,q3] <> 0 or U2[q1,q2,q3] <> 0 or U3[q1,q2,q3] <> 0) then 1 else 0;

printf "Number of terminal nodes = %d\n", sum{q1 in Q1,q2 in Q2,q3 in Q3} suppU[q1,q2,q3];

option solver gurobi;

# GUROBI OPTIONS
# option gurobi_options 'timelim 100';
# option solver_msg 0; # turn off solver messages
# option gurobi_options "quad=1 feastol=1e-09";
option gurobi_options "outlev=1"; #write Gurobi log lines to stdout (default 0)

# COMPUTING A FEASIBLE solution (PHASE I)
problem master_phase1: aux_obj, c11_phase1, c12_phase1, c13_phase1, c21_phase1, c22_phase1, c23_phase1, c3_phase1,sigma, v1, v2, v3, aux_c11, aux_c12, aux_c13, slack_c21, slack_c22, slack_c23, aux_c3;

# COMPUTING AN OPTIMAL solution (PHASE II)
problem master: welfare, c11, c12, c13, c21, c22, c23, c3, sigma, v1, v2;

/* # cubic pricer for phase I
problem pricer_aux: obj_pricer_milp_aux,
const1_milp_sf1, const2_milp_sf2, const3_milp_sf3, rp1_pricer, rp2_pricer, rp3_pricer;

# cubit pricer for phase II
problem pricer: obj_pricer_milp,
const1_milp_sf1, const2_milp_sf2, const3_milp_sf3, rp1_pricer, rp2_pricer, rp3_pricer; */

# quadratic pricer for phase I
problem pricer_aux: obj_pricer_milp_aux, quadratic_z_1, quadratic_z_2, quadratic_z_3, const1_milp_sf1, const2_milp_sf2, const3_milp_sf3, z, rp1_pricer, rp2_pricer, rp3_pricer;

# quadratic pricer for phase II
problem pricer: obj_pricer_milp, quadratic_z_1, quadratic_z_2, quadratic_z_3,
const1_milp_sf1, const2_milp_sf2, const3_milp_sf3, z, rp1_pricer, rp2_pricer, rp3_pricer;

/* # linear pricer v2 phase I
problem pricer_aux: obj_pricer_milp_aux,
c_z123_1, c_z123_2, c_z123_3, c_z123_4,
c_z12_1, c_z12_2, c_z12_3,
c_z13_1, c_z13_2, c_z13_3,
c_z23_1, c_z23_2, c_z23_3,
const1_milp_sf1, const2_milp_sf2, const3_milp_sf3,
rp1_pricer, rp2_pricer, rp3_pricer,
z_123, z_12, z_13, z_23;

# linear pricer v2 phase II
problem pricer: obj_pricer_milp,
c_z123_1, c_z123_2, c_z123_3, c_z123_4,
c_z12_1, c_z12_2, c_z12_3,
c_z13_1, c_z13_2, c_z13_3,
c_z23_1, c_z23_2, c_z23_3,
const1_milp_sf1, const2_milp_sf2, const3_milp_sf3,
rp1_pricer, rp2_pricer, rp3_pricer,
z_123, z_12, z_13, z_23; */


param OPTIMAL default 0;
# number of iterations for the current phase
param it default 0;
# number of iterations for PHASE I
param it_ph1 default 0;
# 0 for phase I (auxiliary problem), 1 for phase II
param ph default 0;

param time_start default 0;
param time_end default 0;

param time_phase1 default 0;
param time_phase2 default 0;

param time_start_all default 0;
let time_start_all := time();

# pure realization plans computed by the pricers
param best_rp1{Q1};
param best_rp2{Q2};
param best_rp3{Q3};
# value of the "most violated" constraint
param best_violation;

#******************************************************************************
# BODY OF THE COL-GEN ALGORITHM
#******************************************************************************
let time_phase1 := time();

repeat{
  let it := it + 1;
  printf "*********Iteration %d\n", it;

  let time_start := time();

  #
  # MASTER PROBLEMS
  #
  printf "********(Ph=%s,it=%d)*********Solving master\n", ph, it;
  if ph == 0 then{
    solve master_phase1;
  } else
    solve master;
  # output
  if flag_do_expand == 1 then expand;
  if flag_print_sol == 1 then {
    printf "Printing phase %s master solutions\n";
    if ph == 0 then display sigma, v1, v2, v3, aux_c11, aux_c12, aux_c13, slack_c21, slack_c22, slack_c23, aux_c3;
    else display sigma, v1, v2, v3;
  }

  #
  # Computing dual variables
  #
  if ph == 0 then {
    let alpha1 := c11_phase1.dual;
    let alpha2 := c12_phase1.dual;
    let alpha3 := c13_phase1.dual;
    let{q1 in Q1} beta1[q1] := c21_phase1[q1].dual;
    let{q2 in Q2} beta2[q2] := c22_phase1[q2].dual;
    let{q3 in Q3} beta3[q3] := c23_phase1[q3].dual;
    let gamma := c3_phase1.dual;
  } else {
    let alpha1 := c11.dual;
    let alpha2 := c12.dual;
    let alpha3 := c13.dual;
    let{q1 in Q1} beta1[q1] := c21[q1].dual;
    let{q2 in Q2} beta2[q2] := c22[q2].dual;
    let{q3 in Q3} beta3[q3] := c23[q3].dual;
    let gamma := c3.dual;
  }
  if flag_print_duals == 1 then{
    printf "Printing phase %s master dual variables\n";
    display alpha1, alpha2, alpha3, beta1, beta2, beta3, gamma;
  }

  let time_end := time() - time_start;
  printf "Ph=%s,it=%d,Time master=%f \n", ph, it, time_end;

  #
  # PRICERS
  #

  let time_start := time();

  let best_violation := -1;
  printf "********(Ph=%s,it=%d)*********Solving pricer\n", ph, it;

  if ph == 0 then{
    solve pricer_aux;
  } else {
    solve pricer;
  }
  if flag_do_expand == 1 then expand;

  if ph == 0 then{
    let best_violation := obj_pricer_milp_aux + gamma;
  } else {
    let best_violation := obj_pricer_milp + gamma;
  }
  printf"********(Ph=%s,it=%d)********* Pricer solved, biggest violation=%f\n",ph,it,best_violation;

  let {qq1 in Q1} best_rp1[qq1] := rp1_pricer[qq1];
  let {qq2 in Q2} best_rp2[qq2] := rp2_pricer[qq2];
  let {qq3 in Q3} best_rp3[qq3] := rp3_pricer[qq3];

  if flag_print_sol == 1 then {
    display best_rp1, best_rp2, best_rp3;
  }

  let OPTIMAL := 1;
  # cut-off for numerical reasons
  if (best_violation > 1e-06) then {
    printf "********(Ph=%s,it=%d)*********Violated inequality found\n", ph, it;

    if flag_print_sol == 1 then {
      # print realization plan player 1
      printf "best_rp1 = (";
      for {qq1 in Q1} if best_rp1[qq1] <> 0 then printf"%s ", qq1;
      printf")\n";
      # print realization plan player 2
      printf "best_rp2 = (";
      for {qq2 in Q2} if best_rp2[qq2] <> 0 then printf"%s ", qq2;
      printf")\n";
      # print realization plan player 3
      printf "best_rp3 = (";
      for {qq3 in Q3} if best_rp3[qq3] <> 0 then printf"%s ", qq3;
      printf")\n";
    }

    let p1_num := p1_num + 1;
    let p2_num := p2_num + 1;
    let p3_num := p3_num + 1;
    let{qq1 in Q1} rp1[p1_num, qq1] := best_rp1[qq1];
    let{qq2 in Q2} rp2[p2_num, qq2] := best_rp2[qq2];
    let{qq3 in Q3} rp3[p3_num, qq3] := best_rp3[qq3];

    let P1P2P3 := P1P2P3 union {(p1_num, p2_num, p3_num)};

    let OPTIMAL := 0;
  }

  let time_end := time() - time_start;
  printf "Ph=%s,it=%d,Time pricer=%f \n", ph, it, time_end;

  if ph == 0 then
     printf "aux_obj=%f\n", aux_obj;
  else
     printf "welfare=%f\n", welfare;

  # Check termination of the col-gen procedure
  printf "********(Ph=%s,it=%d)*********Checking phase termination condition\n", ph, it;
  if OPTIMAL == 1 and ph == 0 then {
    # switch to phase II
    let ph := 1;
    let it_ph1 := it;
    let it := 0;
    let OPTIMAL := 0;

    let time_phase1 := time() - time_phase1;
    let time_phase2 := time();

    if aux_obj > 1e-06 then {
      printf "aux_obj = %f: Phase II problem *apparenty* infeasible; halting\n", aux_obj;
      break;
     }
     print "\n";
  }
}while OPTIMAL <> 1;

let time_phase2 := time() - time_phase2;

printf "LOG: feas=%s opt=%s ph1_it=%d ph2_it=%d time=%f welfare=%f \n", if aux_obj > 1e-09 then 0 else 1, OPTIMAL, it_ph1, it, _ampl_time, welfare;

printf "|Q1|=%d, |Q2|=%d, |Q3|=%d, |H1|=%d, |H2|=%d, |H3|=%d \n", card(Q1), card(Q2), card(Q3), card(H1), card(H2), card(H3);

printf "total time seconds=%d, phase1=%d, phase2=%d  \n", (time()-time_start_all), time_phase1, time_phase2;
